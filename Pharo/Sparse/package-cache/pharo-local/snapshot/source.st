SystemOrganization addCategory: #SparseMatrix!TestCase subclass: #SparseMatrixTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SparseMatrix'!!SparseMatrixTest methodsFor: 'tests' stamp: 'MelkiYasser 2/8/2024 09:27'!testAddSparseMatricesWithoutNils    | matrix1 matrix2 result expectedResult |    matrix1 := #(#(3 1 2 2) #(3 2 1 3) #(3 1 2 3)).    matrix2 := #(#(3 1 2 2) #(3 2 1 3) #(3 1 2 3)).    expectedResult := #(#(3 1 2 2) #(3 2 1 3) #(3 2 4 6)). "Expected result without nils"    "Perform the addition"    result := SparseMatrix new addSparseMatrices: matrix1 with: matrix2.    "Assert that the result matches the expected result"    self assert: result equals: expectedResult.    "Additionally, check for absence of nils"    self deny: (result anySatisfy: [:subArray | subArray includes: nil]).! !!SparseMatrixTest methodsFor: 'tests' stamp: 'MelkiYasser 2/8/2024 09:45'!testCalculateSparsityForMatrix    | matrix sparseMatrix expectedSparsityMessage nonZeroValuesCountBefore nonZeroValuesCountAfter |    "Initialize a SparseMatrix instance"    sparseMatrix := SparseMatrix new.    "Define a test matrix"    matrix := #(#(0 1 0) #(1 0 1) #(0 1 0)).    "Capture the initial non-zero values count"    nonZeroValuesCountBefore := sparseMatrix nonZeroValuesCount.    "Expected output in Transcript based on the sparsity calculation"    expectedSparsityMessage := 'The matrix has higher or equal sparsity than the stored sparsity value.'.    "Perform the sparsity calculation"    sparseMatrix calculateSparsityForMatrix: matrix.    "Capture the updated non-zero values count"    nonZeroValuesCountAfter := sparseMatrix nonZeroValuesCount.    "Assert that the non-zero values count is updated correctly"    self assert: nonZeroValuesCountAfter equals: 4.    "Assert that the correct message is printed to the Transcript based on sparsity"    self assert: (Transcript contents includesSubstring: expectedSparsityMessage).! !!SparseMatrixTest methodsFor: 'tests' stamp: 'MelkiYasser 2/8/2024 07:53'!testConvertToSparseRepresentationAndReconstruct    | originalDenseMatrix sparseMatrix reconstructedDenseMatrix |    "Initialize the original dense matrix"    originalDenseMatrix := #(        #(0 1 0)        #(2 0 3)        #(0 0 0)    ).    "Convert the original dense matrix to its sparse representation"    sparseMatrix := SparseMatrix new convertToSparseRepresentation: originalDenseMatrix.    "Reconstruct the dense matrix from the sparse representation"    reconstructedDenseMatrix := SparseMatrix new reconstructMatrixFromSparseRepresentation: sparseMatrix.    "Assert that the reconstructed dense matrix matches the original dense matrix"    self assert: reconstructedDenseMatrix equals: originalDenseMatrix.! !!SparseMatrixTest methodsFor: 'tests' stamp: 'MelkiYasser 2/8/2024 07:19'!testNonZeroValuesCountGetterSetter    | sparseMatrix |    sparseMatrix := SparseMatrix new.    sparseMatrix nonZeroValuesCount: 5.    self assert: (sparseMatrix nonZeroValuesCount) equals: 5.! !!SparseMatrixTest methodsFor: 'tests' stamp: 'MelkiYasser 2/8/2024 08:02'!testReconstructFromSparseToOriginalDenseMatrix    | sparseMatrix expectedDenseMatrix reconstructedDenseMatrix |    "Initialize the sparse matrix representation"    sparseMatrix := #(#(5 1 1 2 2 2 2 3 3 3 3 4 4 4) #(4 1 2 1 2 3 4 1 2 3 4 1 2 4) #(13 3 1 3 2 1 3 1 1 2 3 1 4 5)).    "Expected dense matrix after reconstruction"    expectedDenseMatrix := #(        #(3 1 0 0)        #(3 2 1 3)        #(1 1 2 3)        #(1 4 0 5)        #(0 0 0 0)    ).    "Reconstruct the dense matrix from the sparse representation"    reconstructedDenseMatrix := SparseMatrix new reconstructMatrixFromSparseRepresentation: sparseMatrix.    "Assert that the reconstructed dense matrix matches the expected dense matrix"    self assert: reconstructedDenseMatrix equals: expectedDenseMatrix.! !!SparseMatrixTest methodsFor: 'tests' stamp: 'MelkiYasser 2/8/2024 07:12'!testSparsityGetterAndSetter    | sparseMatrix |    sparseMatrix := SparseMatrix new.    sparseMatrix sparsity: 0.5.    self assert: sparseMatrix sparsity equals: 0.5.! !!SparseMatrixTest methodsFor: 'tests' stamp: 'MelkiYasser 2/8/2024 09:43'!testTransposeSparseMatrix    | sparseMatrix expectedTransposedMatrix transposedSparseMatrix |    sparseMatrix := #(        #(5 1 1 2 2 2 2 3 3 3 3 4 4 4)         #(4 1 2 1 2 3 4 1 2 3 4 1 2 4)         #(13 3 1 3 2 1 3 1 1 2 3 1 4 5)    ).    expectedTransposedMatrix := #(        #(4 1 2 1 2 3 4 1 2 3 4 1 2 4)         #(5 1 1 2 2 2 2 3 3 3 3 4 4 4)         #(13 3 1 3 2 1 3 1 1 2 3 1 4 5)    ).    transposedSparseMatrix := SparseMatrix new transposeSparseMatrix: sparseMatrix.    self assert: (transposedSparseMatrix = expectedTransposedMatrix).! !Object subclass: #SparseMatrix	instanceVariableNames: 'sparsity nonZeroValuesCount'	classVariableNames: ''	poolDictionaries: ''	category: 'SparseMatrix'!!SparseMatrix methodsFor: 'accessing' stamp: 'MelkiYasser 2/8/2024 09:26'!addSparseMatrices: matrix1 with: matrix2    "Add two sparse matrices and return the result in sparse format."        | additionResult rows cols nonZeroCount1 nonZeroCount2 nonZeroCountResult apos bpos |        "Extract metadata"    rows := ((matrix1 at: 1) at: 1).    cols := ((matrix1 at: 2) at: 1).    nonZeroCount1 := ((matrix1 at: 3) at: 1).    nonZeroCount2 := ((matrix2 at: 3) at: 1).        "Initialize the result sparse matrix structure"    additionResult := Array new: 3.    additionResult at: 1 put: (Array new: (nonZeroCount1 + nonZeroCount2 + 1)).    additionResult at: 2 put: (Array new: (nonZeroCount1 + nonZeroCount2 + 1)).    additionResult at: 3 put: (Array new: (nonZeroCount1 + nonZeroCount2 + 1)).    (additionResult at: 1) at: 1 put: rows.    (additionResult at: 2) at: 1 put: cols.    nonZeroCountResult := 0.        "Initialize positions"    apos := 2.    bpos := 2.        [apos <= (nonZeroCount1 + 1) and: [bpos <= (nonZeroCount2 + 1)]] whileTrue: [        | rowA colA valA rowB colB valB |        rowA := ((matrix1 at: 1) at: apos).        colA := ((matrix1 at: 2) at: apos).        valA := ((matrix1 at: 3) at: apos).        rowB := ((matrix2 at: 1) at: bpos).        colB := ((matrix2 at: 2) at: bpos).        valB := ((matrix2 at: 3) at: bpos).                ((rowA < rowB) or: [(rowA = rowB) and: [colA < colB]]) ifTrue: [            "A's position is before B's, so add A's current element to the result"            nonZeroCountResult := nonZeroCountResult + 1.            (additionResult at: 1) at: (nonZeroCountResult + 1) put: rowA.            (additionResult at: 2) at: (nonZeroCountResult + 1) put: colA.            (additionResult at: 3) at: (nonZeroCountResult + 1) put: valA.            apos := apos + 1.        ] ifFalse: [            ((rowA > rowB) or: [(rowA = rowB) and: [colA > colB]]) ifTrue: [                "B's position is before A's, so add B's current element to the result"                nonZeroCountResult := nonZeroCountResult + 1.                (additionResult at: 1) at: (nonZeroCountResult + 1) put: rowB.                (additionResult at: 2) at: (nonZeroCountResult + 1) put: colB.                (additionResult at: 3) at: (nonZeroCountResult + 1) put: valB.                bpos := bpos + 1.            ] ifFalse: [                "Positions are the same, add values"                valA := valA + valB.                (valA ~= 0) ifTrue: [                    nonZeroCountResult := nonZeroCountResult + 1.                    (additionResult at: 1) at: (nonZeroCountResult + 1) put: rowA.                    (additionResult at: 2) at: (nonZeroCountResult + 1) put: colA.                    (additionResult at: 3) at: (nonZeroCountResult + 1) put: valA.                ].                apos := apos + 1.                bpos := bpos + 1.            ]        ].    ].        "Handle remaining elements of A"    [apos <= (nonZeroCount1 + 1)] whileTrue: [        nonZeroCountResult := nonZeroCountResult + 1.        (additionResult at: 1) at: (nonZeroCountResult + 1) put: ((matrix1 at: 1) at: apos).        (additionResult at: 2) at: (nonZeroCountResult + 1) put: ((matrix1 at: 2) at: apos).        (additionResult at: 3) at: (nonZeroCountResult + 1) put: ((matrix1 at: 3) at: apos).        apos := apos + 1.    ].        "Handle remaining elements of B"    [bpos <= (nonZeroCount2 + 1)] whileTrue: [        nonZeroCountResult := nonZeroCountResult + 1.        (additionResult at: 1) at: (nonZeroCountResult + 1) put: ((matrix2 at: 1) at: bpos).        (additionResult at: 2) at: (nonZeroCountResult + 1) put: ((matrix2 at: 2) at: bpos).        (additionResult at: 3) at: (nonZeroCountResult + 1) put: ((matrix2 at: 3) at: bpos).        bpos := bpos + 1.    ].        "Update non-zero count in the result"    (additionResult at: 3) at: 1 put: nonZeroCountResult.    "Before returning additionResult, remove nils by resizing the arrays"    nonZeroCountResult := nonZeroCountResult + 1. "Adjust for metadata"    additionResult at: 1 put: ((additionResult at: 1) copyFrom: 1 to: nonZeroCountResult).    additionResult at: 2 put: ((additionResult at: 2) copyFrom: 1 to: nonZeroCountResult).    additionResult at: 3 put: ((additionResult at: 3) copyFrom: 1 to: nonZeroCountResult).        ^additionResult.    ! !!SparseMatrix methodsFor: 'accessing' stamp: 'MelkiYasser 2/7/2024 20:30'!calculateSparsityForMatrix: aMatrix    | zeroCount totalElements calculatedSparsity |    "Ensure sparsity has a default value if not set"    sparsity ifNil: [ sparsity := 0.5 ].        zeroCount := aMatrix inject: 0 into: [:sum :row |        sum + (row count: [:element | element = 0])].    totalElements := aMatrix size * (aMatrix first size).    calculatedSparsity := zeroCount asFloat / totalElements.    self nonZeroValuesCount: ((aMatrix size * (aMatrix first size)) - zeroCount).    calculatedSparsity >= sparsity        ifTrue: [ Transcript show: 'The matrix has higher or equal sparsity than the stored sparsity value.'; cr. ]        ifFalse: [ Transcript show: 'The matrix has lower sparsity than the stored sparsity value.'; cr. ].! !!SparseMatrix methodsFor: 'accessing' stamp: 'MelkiYasser 2/8/2024 05:32'!convertToSparseRepresentation: matrix    | rows cols nonZeroCount sparseRepresentation k |    rows := matrix size.    cols := (matrix at: 1) size.    nonZeroCount := 0.    matrix do: [:eachRow |        eachRow do: [:element |            element ~= 0 ifTrue: [ nonZeroCount := nonZeroCount + 1 ]]].    sparseRepresentation := Array new: 3.    sparseRepresentation at: 1 put: (Array new: nonZeroCount + 1).    sparseRepresentation at: 2 put: (Array new: nonZeroCount + 1).    sparseRepresentation at: 3 put: (Array new: nonZeroCount + 1).    sparseRepresentation first at: 1 put: rows.    sparseRepresentation second at: 1 put: cols.    sparseRepresentation third at: 1 put: nonZeroCount.    k := 2.    1 to: rows do: [:i |        1 to: cols do: [:j |            ((matrix at: i) at: j) ~= 0 ifTrue: [                sparseRepresentation first at: k put: i.                sparseRepresentation second at: k put: j.                sparseRepresentation third at: k put: ((matrix at: i) at: j).                k := k + 1.            ]]].    "self printMatrix: " ^ sparseRepresentation .    "Print sparse representation in the Transcript"! !!SparseMatrix methodsFor: 'accessing' stamp: 'MelkiYasser 2/7/2024 16:21'!nonZeroValuesCount    "Get the value of nonZeroValuesCount"    ^ nonZeroValuesCount.! !!SparseMatrix methodsFor: 'accessing' stamp: 'MelkiYasser 2/7/2024 16:21'!nonZeroValuesCount: aCount    "Set the value of nonZeroValuesCount"    nonZeroValuesCount := aCount.! !!SparseMatrix methodsFor: 'accessing' stamp: 'MelkiYasser 2/7/2024 20:38'!printMatrix: matrix    "Prints each row of the given matrix on a separate line."    matrix do: [:eachRow |        Transcript            show: (eachRow inject: '' into: [:str :element | str, element printString, ' ']);            cr.  "Move to the next line for each row"    ].! !!SparseMatrix methodsFor: 'accessing' stamp: 'MelkiYasser 2/8/2024 07:28'!reconstructMatrixFromSparseRepresentation: sparseRepresentation	| reconstructedMatrix rows cols nonZeroValues |	"Extract matrix dimensions and non-zero values count from the first elements"	rows := (sparseRepresentation at: 1) at: 1.	cols := (sparseRepresentation at: 2) at: 1.	nonZeroValues := (sparseRepresentation at: 3) at: 1.	"Initialize the reconstructed matrix with zeros"	reconstructedMatrix := Array new: rows.	1 to: rows do: [ :i |	reconstructedMatrix at: i put: (Array new: cols withAll: 0) ].	"Iterate through the sparse representation to fill in the matrix"	1 to: nonZeroValues do: [ :i |		| row col value |		row := (sparseRepresentation at: 1) at: i + 1.		col := (sparseRepresentation at: 2) at: i + 1.		value := (sparseRepresentation at: 3) at: i + 1.		"Check if row and col are within the valid range of reconstructedMatrix"		row > 0 & (row <= rows) & (col > 0) & (col <= cols)			ifTrue: [ (reconstructedMatrix at: row) at: col put: value ]			ifFalse: [ "Handle the case where row or col is out of bounds"				Transcript					show:						('Warning: Ignoring invalid indices (' , row printString , ', '						 , col) printString , ')';					cr				"You can choose to throw an exception or take other appropriate action" ] ].	"Print the dense matrix using the previously defined method"	^ reconstructedMatrix! !!SparseMatrix methodsFor: 'accessing' stamp: 'MelkiYasser 2/7/2024 16:21'!sparsity    "Get the value of sparsity"    ^ sparsity.! !!SparseMatrix methodsFor: 'accessing' stamp: 'MelkiYasser 2/7/2024 20:30'!sparsity: aSparsity    "Set the sparsity value. If the sparsity variable is nil, initialize it with a default value."    sparsity := aSparsity .   ! !!SparseMatrix methodsFor: 'accessing' stamp: 'MelkiYasser 2/8/2024 09:37'!transposeSparseMatrix: sparseRepresentation    | transposedSparseRepresentation rows cols nonZeroValues |    "Extract matrix dimensions and non-zero values count from the metadata"    rows := sparseRepresentation first first.    cols := sparseRepresentation second first.    nonZeroValues := sparseRepresentation third first.    "Initialize the transposed sparse matrix structure with swapped rows and cols"    transposedSparseRepresentation := Array new: 3.    transposedSparseRepresentation at: 1 put: (Array new: nonZeroValues + 1).    transposedSparseRepresentation at: 2 put: (Array new: nonZeroValues + 1).    transposedSparseRepresentation at: 3 put: (Array new: nonZeroValues + 1).        "Update the metadata for the transposed matrix"    transposedSparseRepresentation first at: 1 put: cols.    transposedSparseRepresentation second at: 1 put: rows.    transposedSparseRepresentation third at: 1 put: nonZeroValues.    "Transpose the non-zero elements"    1 to: nonZeroValues do: [ :i |        | row col value |        row := sparseRepresentation first at: i + 1.        col := sparseRepresentation second at: i + 1.        value := sparseRepresentation third at: i + 1.        "Swap row and column indices for the transposed matrix"        transposedSparseRepresentation first at: i + 1 put: col.        transposedSparseRepresentation second at: i + 1 put: row.        transposedSparseRepresentation third at: i + 1 put: value.    ].    ^transposedSparseRepresentation.! !